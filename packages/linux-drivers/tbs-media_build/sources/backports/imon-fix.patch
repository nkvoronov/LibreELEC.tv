diff -Naur a/drivers/media/rc/imon.c b/drivers/media/rc/imon.c
--- a/drivers/media/rc/imon.c	2018-02-06 00:25:20.000000000 +0200
+++ b/drivers/media/rc/imon.c	2018-02-09 02:01:55.673768718 +0200
@@ -1,9 +1,9 @@
 /*
- *   imon.c:	input and display driver for SoundGraph iMON IR/VFD/LCD
+ *   imon.c: input and display driver for SoundGraph iMON IR/VFD/LCD
  *
  *   Copyright(C) 2010  Jarod Wilson <jarod@wilsonet.com>
  *   Portions based on the original lirc_imon driver,
- *	Copyright(C) 2004  Venky Raju(dev@venky.ws)
+ *   Copyright(C) 2004  Venky Raju(dev@venky.ws)
  *
  *   Huge thanks to R. Geoff Newbury for invaluable debugging on the
  *   0xffdc iMON devices, and for sending me one to hack on, without
@@ -466,6 +466,15 @@
 module_param(pad_stabilize, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(pad_stabilize, "Apply stabilization algorithm to iMON PAD presses in arrow key mode. 0=disable, 1=enable (default).");
 
+static int packet_delay_manually = 0;
+module_param(packet_delay_manually, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(packet_delay_manually, "Packet delay manually: 0=no, 1=yes (default: no)");
+
+static int send_packet_delay = 5;
+module_param(send_packet_delay, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(send_packet_delay, "Minimum delay between send_packet() calls (default 5ms)");
+
+
 /*
  * In certain use cases, mouse mode isn't really helpful, and could actually
  * cause confusion, so allow disabling it when the IR device is open.
@@ -657,7 +666,13 @@
 	 * send_packet can get called so rapidly as to overwhelm the device,
 	 * particularly on faster systems and/or those with quirky usb.
 	 */
-	timeout = msecs_to_jiffies(ictx->send_packet_delay);
+
+	if (packet_delay_manually) {
+	    timeout = msecs_to_jiffies(send_packet_delay);
+	} else {
+	    timeout = msecs_to_jiffies(ictx->send_packet_delay);
+	}
+
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout(timeout);
 
@@ -1310,8 +1325,7 @@
 	return keycode;
 }
 
-static bool imon_mouse_event(struct imon_context *ictx,
-			     unsigned char *buf, int len)
+static bool imon_mouse_event(struct imon_context *ictx, unsigned char *buf, int len)
 {
 	signed char rel_x = 0x00, rel_y = 0x00;
 	u8 right_shift = 1;
@@ -1733,8 +1747,8 @@
 	}
 
 	if (debug) {
-		printk(KERN_INFO "intf%d decoded packet: %*ph\n",
-		       intf, len, buf);
+	    printk(KERN_INFO "intf%d decoded packet: %*ph\n", intf, len, buf);
+	    printk(" key code - %d\n", ictx->kc);
 	}
 
 	press_type = imon_parse_press_type(ictx, buf, ktype);
@@ -1766,6 +1780,94 @@
 		msec = ktime_ms_delta(t, prev_time);
 		if (msec < ictx->idev->rep[REP_DELAY]) {
 			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_RIGHT repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_RIGHT && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_LEFT repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_LEFT && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_UP repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_UP && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_DOWN repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_DOWN && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_ESC repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_ESC && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_ENTER repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_ENTER && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_MENU repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_MENU && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_MEDIA repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_MEDIA && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_EXIT repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_EXIT && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_SELECT repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_SELECT && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
+			return;
+		}
+	}
+	/* KEY_SELECT repeats from knob need to be suppressed */
+	if (ictx->kc == KEY_SELECT && ictx->kc == ictx->last_keycode) {
+		msec = ktime_ms_delta(t, prev_time);
+		if (msec < ictx->idev->rep[REP_DELAY]) {
+			spin_unlock_irqrestore(&ictx->kc_lock, flags);
 			return;
 		}
 	}
